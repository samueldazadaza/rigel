<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>游닇txt procesar</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .contenedor { display: flex; gap: 20px; }
    .campo { flex: 1; display: flex; flex-direction: column; }
    .editor, .resultado {
      width: 100%;
      min-height: 200px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-family: Consolas, monospace;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }
    .editor { background: #fff; }
    .resultado { background: #f9f9f9; }
    label { font-weight: bold; margin-bottom: 6px; }
    .label { color: #0066cc; }   /* azul */
    .number { color: #2e7d32; }  /* verde */
    .letters { color: #d35400; } /* naranja */
    .timeago { color: #9c27b0; font-style: italic; margin-left: 10px; }
    .label-resultado { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 30px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
      box-shadow: 0 2px 3px rgba(0,0,0,0.3);
    }
    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(30px);
    }
    .toggle-label {
      margin-left: 10px;
      font-size: 12px;
      font-weight: 600;
      color: #555;
      user-select: none;
    }
    .toggle-container {
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body style="font-size: 10px">
  <nav class="nav nav-tabs mb-3 bg-light container">
    <a class="nav-item nav-link" href="#">Tabla</a>
    <a class="nav-item nav-link" href="./dashboard.html">DashBoard</a>
    <a class="nav-item nav-link active" href="./extrae-txt.html">extrae-txt</a>
    <a class="nav-item nav-link" href="./index2.html">Tabla-Filtro</a>
  </nav>

  <h2>Procesar texto</h2>

  <!-- Switch para activar/desactivar colores -->
  <div class="switch-container">
    <label>
      <input type="checkbox" id="colorSwitch" checked>
      Activar colores
    </label>
  </div>

  <div class="contenedor">
    <div class="campo">
      <label for="input">Texto de entrada:</label>
      <div id="input" class="editor" contenteditable="true"></div>
    </div>

    <div class="campo">
      <label for="output">Resultado:</label>
      <div id="output" class="resultado"></div>
      <button class="btn btn-sm btn-primary mt-2" onclick="copiar()">Copiar resultado</button>
      <!-- Bot칩n Google Maps + tiempo -->
      <div id="extraInfo" class="d-flex align-items-center mt-2"></div>
    </div>
  </div>

  <script>
    function calcularTiempo(fechaStr, horaStr) {
      try {
        const [dia, mes, anio] = fechaStr.split("-");
        const [hora, minuto] = horaStr.split(":");
        const fechaEvento = new Date(anio, mes - 1, dia, hora, minuto);
        const ahora = new Date();
        const diffMs = ahora - fechaEvento;
        if (diffMs < 0) return "en el futuro";

        const diffMin = Math.floor(diffMs / 60000);
        const diffHoras = Math.floor(diffMin / 60);
        const diffDias = Math.floor(diffHoras / 24);

        if (diffDias > 0) return `${diffDias} d칤a(s) y ${diffHoras % 24} hora(s) atr치s`;
        if (diffHoras > 0) return `${diffHoras} hora(s) y ${diffMin % 60} minuto(s) atr치s`;
        return `${diffMin} minuto(s) atr치s`;
      } catch {
        return "";
      }
    }

    function procesar(texto) {
      const regex = /([\p{L}\p{M}\s\-]+):\s*([^/]+)(?=\/|$)/gu;
      const matches = [...texto.matchAll(regex)];
      const useColors = document.getElementById("colorSwitch").checked;

      // Funci칩n para normalizar etiquetas para comparaci칩n
      function normalizarEtiqueta(etq) {
        return etq.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").trim();
      }

      // Crear un array de todos los campos extra칤dos
      const todosLosCampos = matches.map(m => ({
        etiqueta: m[1].trim(),
        value: m[2].trim()
      }));

      // Secuencia de orden deseada con etiquetas de salida y posibles variaciones de entrada
      const ordenCampos = [
        { etiquetaSalida: "Detalle del reporte", keys: ["detalle del reporte"], esTitulo: true },
        { etiquetaSalida: "Nombre de contacto", keys: ["nombre de contacto", "reporta", "contacto"], valorFijo: "AuxiliarSTS" },
        { etiquetaSalida: "Tel칠fono de contacto", keys: ["telefono de contacto", "telefono", "tel"], valorFijo: "3242911287" },
        { etiquetaSalida: "Tabla", keys: ["tabla"] },
        { etiquetaSalida: "Ruta", keys: ["ruta"] },
        { etiquetaSalida: "Viaje", keys: ["viaje"] },
        { etiquetaSalida: "Servicio", keys: ["servicio"], valorFijo: "Zonal" },
        { etiquetaSalida: "Descripci칩n del reporte", keys: ["descripcion del reporte", "descripcion"] },
        { etiquetaSalida: "Fecha y hora de novedad", keys: ["fecha y hora de novedad", "fecha", "hora"], esCombinado: true },
        { etiquetaSalida: "C칩digo operador (si aplica)", keys: ["codigo operador", "operador", "codigo"] },
        { etiquetaSalida: "La Novedad es intermitente o durante toda la ruta?", keys: ["la novedad es intermitente o durante toda la ruta", "intermitente"], valorFijo: "Durante la ruta" },
        { etiquetaSalida: "Ubicaci칩n aproximada de la novedad", keys: ["ubicacion aproximada de la novedad", "ubicacion aproximada", "direccion", "direcci칩n"] }
      ];

      let direccionValor = null;
      let fechaValor = null;
      let horaValor = null;

      // Buscar valores para "Fecha y hora de novedad" combinado
      let fechaCombinada = null;
      let horaCombinada = null;
      todosLosCampos.forEach(c => {
        const etqNorm = normalizarEtiqueta(c.etiqueta);
        if (etqNorm.includes("fecha y hora de novedad")) {
          fechaCombinada = c.value;
        } else if (etqNorm === "fecha") {
          fechaValor = c.value;
        } else if (etqNorm === "hora") {
          horaValor = c.value;
        }
      });

      // Reordenar campos seg칰n la secuencia - SIEMPRE mostrar todos
      const camposOrdenados = [];
      const camposUsados = new Set();
      let fechaIdxUsado = -1;
      let horaIdxUsado = -1;

      // Recorrer la secuencia de orden y buscar campos coincidentes
      ordenCampos.forEach(item => {
        let campoEncontrado = null;
        let indicesEncontrados = [];

        // Si es "Fecha y hora de novedad" combinado, buscar primero el combinado, luego combinar Fecha y Hora
        if (item.esCombinado) {
          // Buscar campo combinado completo
          for (const ordenKey of item.keys) {
            if (ordenKey.includes("fecha y hora")) {
              const resultado = todosLosCampos.find((c, idx) => {
                if (camposUsados.has(idx)) return false;
                const etqNorm = normalizarEtiqueta(c.etiqueta);
                return etqNorm.includes("fecha y hora de novedad");
              });
              if (resultado) {
                campoEncontrado = resultado;
                indicesEncontrados.push(todosLosCampos.indexOf(resultado));
                break;
              }
            }
          }

          // Si no se encontr칩 combinado, buscar Fecha y Hora por separado
          if (!campoEncontrado && fechaValor && horaValor) {
            const fechaIdx = todosLosCampos.findIndex((c, idx) => 
              !camposUsados.has(idx) && normalizarEtiqueta(c.etiqueta) === "fecha"
            );
            const horaIdx = todosLosCampos.findIndex((c, idx) => 
              !camposUsados.has(idx) && normalizarEtiqueta(c.etiqueta) === "hora"
            );
            
            if (fechaIdx >= 0 && horaIdx >= 0) {
              campoEncontrado = {
                etiqueta: item.etiquetaSalida,
                value: `${fechaValor} ${horaValor}`
              };
              indicesEncontrados.push(fechaIdx, horaIdx);
              fechaIdxUsado = fechaIdx;
              horaIdxUsado = horaIdx;
            }
          }
        } else {
          // Buscar campo coincidente normal
          for (const ordenKey of item.keys) {
            const resultado = todosLosCampos.find((c, idx) => {
              // Si es Fecha o Hora y ya se usaron para el campo combinado, ignorarlos
              if (idx === fechaIdxUsado || idx === horaIdxUsado) return false;
              if (camposUsados.has(idx)) return false;
              
              const etqNorm = normalizarEtiqueta(c.etiqueta);
              
              // Mapeos espec칤ficos
              // Si estamos buscando "Operador", solo coincidir con "operador" exacto
              if (item.etiquetaSalida.includes("operador")) {
                return etqNorm === "operador" || etqNorm === "codigo operador";
              }
              
              // Si estamos buscando "Direcci칩n" o "Ubicaci칩n", usar esos campos espec칤ficamente
              if (item.etiquetaSalida.includes("Ubicaci칩n")) {
                return etqNorm.includes("direccion") || etqNorm.includes("ubicacion");
              }
              
              // Si estamos buscando "Nombre de contacto", buscar "reporta"
              if (item.etiquetaSalida.includes("Nombre de contacto")) {
                return etqNorm === "reporta" || etqNorm.includes("nombre de contacto") || etqNorm.includes("contacto");
              }
              
              // Comparaci칩n general
              return etqNorm === ordenKey || etqNorm.includes(ordenKey) || ordenKey.includes(etqNorm);
            });

            if (resultado) {
              campoEncontrado = resultado;
              indicesEncontrados.push(todosLosCampos.indexOf(resultado));
              break;
            }
          }
        }

        // Agregar el campo encontrado, valor fijo, o uno vac칤o
        // Si tiene valor fijo, siempre usar ese valor (ignora el input)
        if (item.valorFijo) {
          camposOrdenados.push({
            etiqueta: item.etiquetaSalida,
            value: item.valorFijo
          });
        } else if (campoEncontrado) {
          camposOrdenados.push({
            etiqueta: item.etiquetaSalida,
            value: campoEncontrado.value
          });
          
          indicesEncontrados.forEach(idx => {
            if (idx >= 0) camposUsados.add(idx);
          });

          // Mantener compatibilidad con funcionalidad existente
          const etqNorm = normalizarEtiqueta(campoEncontrado.etiqueta || item.etiquetaSalida);
          if (etqNorm.includes("direccion") || etqNorm.includes("ubicacion")) {
            direccionValor = campoEncontrado.value;
          }
        } else {
          // Campo no encontrado, agregarlo vac칤o
          camposOrdenados.push({
            etiqueta: item.etiquetaSalida,
            value: "",
            esVacio: true
          });
        }
      });

      // Buscar direcci칩n para Google Maps (puede venir de cualquier campo relacionado)
      if (!direccionValor) {
        todosLosCampos.forEach(c => {
          const etqNorm = normalizarEtiqueta(c.etiqueta);
          if (etqNorm.includes("direccion") || etqNorm.includes("ubicacion")) {
            direccionValor = c.value;
          }
        });
      }

      // Extraer descripci칩n del reporte del texto inicial si no viene como campo
      const descripcionCampo = camposOrdenados.find(c => normalizarEtiqueta(c.etiqueta).includes("descripcion"));
      if (descripcionCampo) {
        if (!descripcionCampo.value) {
          // Buscar texto antes del primer campo con ":"
          const primerMatch = matches[0];
          if (primerMatch) {
            const inicioTexto = texto.substring(0, texto.indexOf(primerMatch[0])).trim();
            // Limpiar texto inicial: remover **, / al final, y espacios extra
            descripcionCampo.value = inicioTexto
              .replace(/\*\*/g, "")           // Remover asteriscos dobles
              .replace(/\/\s*$/, "")          // Remover "/" al final con espacios
              .replace(/\s+/g, " ")           // Reemplazar m칰ltiples espacios por uno
              .trim();
          }
        }
        // Limpiar "Novedades SIRCI" del texto (si existe valor, tanto extra칤do como del input)
        if (descripcionCampo.value) {
          descripcionCampo.value = descripcionCampo.value
            .replace(/Novedades SIRCI/gi, "")  // Remover "Novedades SIRCI" (case insensitive)
            .replace(/\s+/g, " ")              // Reemplazar m칰ltiples espacios por uno
            .trim();
        }
      }

      // Generar HTML de salida
      const resultadoColores = camposOrdenados.map(campo => {
        // Si es el t칤tulo, mostrarlo sin valor
        if (campo.esTitulo) {
          return "<strong>Detalle del reporte</strong>";
        }

        const etiqueta = campo.etiqueta;
        const value = campo.value || "";
        const label = useColors
          ? `<span class="label">${etiqueta}:</span>`
          : `${etiqueta}:`;

        if (useColors) {
          if (value && /^[0-9]+$/.test(value)) {
            return `${label} <span class="number">${value}</span>`;
          } else if (value && /^[A-Za-z츼칄칈칍칔칖칌치칠칤칩칰칲침\s]+$/.test(value)) {
            return `${label} <span class="letters">${value}</span>`;
          } else {
            return `${label} ${value}`;
          }
        } else {
          return `${label} ${value}`;
        }
      }).join("<br>");

      document.getElementById("output").innerHTML = resultadoColores;

      // Mostrar bot칩n de Google Maps y tiempo juntos
      const extraDiv = document.getElementById("extraInfo");
      extraDiv.innerHTML = "";
      if (direccionValor) {
        const direccionEncoded = encodeURIComponent(direccionValor);
        const mapsBtn = `<a href="https://www.google.com/maps/dir/${direccionEncoded} bogota/Greenmovil" target="_blank" class="btn btn-sm btn-success">Ver en Google Maps</a>`;
        let tiempoTxt = "";
        if (fechaValor && horaValor) {
          tiempoTxt = `<span class="timeago">${calcularTiempo(fechaValor, horaValor)}</span>`;
        }
        extraDiv.innerHTML = mapsBtn + tiempoTxt;
      }
    }

    document.getElementById("input").addEventListener("input", (event) => {
      const texto = event.target.innerText;
      if (texto.length > 0) {
        procesar(texto);
      } else {
        document.getElementById("output").innerHTML = "";
        document.getElementById("extraInfo").innerHTML = "";
      }
    });

    document.getElementById("colorSwitch").addEventListener("change", () => {
      const texto = document.getElementById("input").innerText;
      if (texto.length > 0) {
        procesar(texto);
      }
    });

    function copiar() {
      const outputDiv = document.getElementById("output");
      const range = document.createRange();
      range.selectNodeContents(outputDiv);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      document.execCommand("copy");
      //alert("Resultado copiado con formato y saltos de l칤nea.");
    }
  </script></body>
</html>
